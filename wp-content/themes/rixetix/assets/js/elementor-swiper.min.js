class rixetixSwiperBase extends elementorModules.frontend.handlers.Base {
    getDefaultSettings() {
        return {
            selectors: {
                carousel: `.${elementorFrontend.config.swiperClass}`,
                slideContent: ".swiper-slide"
            }
        }
    }
    getDefaultElements() {
        var e = this.getSettings("selectors");
        const t = {
            $swiperContainer: this.$element.find(e.carousel)
        };
        return t.$slides = t.$swiperContainer.find(e.slideContent), t
    }
    getSwiperSettings() {
        const s = this.getElementSettings(),
            e = s.slides_to_show || 3,
            t = "1" === e,
            i = elementorFrontend.config.responsive.activeBreakpoints,
            n = {
                mobile: 1,
                tablet: t ? 1 : 2
            },
            o = {
                slidesPerView: e,
                loop: "yes" === s.infinite,
                speed: s.speed,
                handleElementorBreakpoints: !0,
                watchSlidesVisibility: !0,
                breakpoints: {}
            };
        let a = e,
            r = 0;
        s.spaceBetween && (o.spaceBetween = s.spaceBetween.size, r = s.spaceBetween.size || 0), Object.keys(i).reverse().forEach(e => {
            var t = n[e] || a;
            o.breakpoints[i[e].value] = {
                slidesPerView: +s["slides_to_show_" + e] || t,
                slidesPerGroup: +s["slides_to_scroll_" + e] || 1
            }, a = +s["slides_to_show_" + e] || t, void 0 !== s["spaceBetween_" + e] && (o.breakpoints[i[e].value].spaceBetween = +s["spaceBetween_" + e].size || r, r = +s["spaceBetween_" + e].size || 0)
        }), "yes" === s.infinite && "" !== s.loopAdditionalSlides && (o.loopAdditionalSlides = s.loopAdditionalSlides), "yes" === s.autoplay && (o.autoplay = {
            delay: s.autoplay_speed,
            disableOnInteraction: "yes" === s.pause_on_interaction
        }), "yes" === s.mousewheel && (o.mousewheel = !0), "yes" === s.centeredslides && (o.centeredSlides = !0), "no" === s.allowTouchMove && (o.allowTouchMove = !1), "yes" === s.autoheight ? o.autoHeight = !0 : o.autoHeight = !1, "yes" === s.infinite ? o.loop = !0 : o.loop = !1, "yes" === s.lazyload && (o.lazy = !0), t ? (o.effect = s.effect, "fade" === s.effect && (o.fadeEffect = {
            crossFade: !0
        }), "cards" === s.effect && (o.grabCursor = !0, o.cardsEffect = {
            perSlideRotate: 0,
            perSlideOffset: 5
        })) : o.slidesPerGroup = +s.slides_to_scroll || 1;
        var l = "arrows" === s.navigation || "both" === s.navigation,
            p = "dots" === s.navigation || "both" === s.navigation || "custom" === s.navigation;
        return l && (o.navigation = {
            prevEl: this.$element.find(".elementor-swiper-button-prev").get(0),
            nextEl: this.$element.find(".elementor-swiper-button-next").get(0)
        }), p && (o.pagination = {
            el: this.$element.find(".swiper-pagination").get(0),
            type: "bullets",
            clickable: !0
        }), void 0 !== s.enable_scrollbar && "yes" === s.enable_scrollbar && (o.scrollbar = {
            el: this.$element.find(".swiper-scrollbar").get(0),
            hide: !1,
            draggable: !0
        }), "vertical" === s.direction && (o.direction = "vertical", o.breakpoints = {}, void 0 !== s.reversedirection && "yes" === s.reversedirection && (o.autoplay = {
            reverseDirection: !0
        }), "yes" !== s.showheight && (o.slidesPerView = 1, o.on = {
            init: function(e) {
                var t = e.slides[e.activeIndex].children[0];
                jQuery(e.$el).css({
                    height: t.clientHeight
                })
            },
            slideChange: function(e) {
                var t = e.slides[e.activeIndex].children[0];
                jQuery(e.$el).css({
                    height: t.clientHeight
                })
            }
        })), o
    }
    updateSwiperOption(e) {
        const t = this.getElementSettings(),
            s = t[e],
            i = this.swiper.params;
        switch (e) {
            case "image_spacing_custom":
                i.spaceBetween = s.size || 0;
                break;
            case "autoplay_speed":
                i.autoplay.delay = s;
                break;
            case "speed":
                i.speed = s
        }
        this.swiper.update()
    }
    getChangeableProperties() {
        return {
            pause_on_hover: "pauseOnHover",
            autoplay_speed: "delay",
            speed: "speed",
            image_spacing_custom: "spaceBetween"
        }
    }
    onElementChange(e) {
        var t;
        this.getChangeableProperties()[e] && ("pause_on_hover" === e ? (t = this.getElementSettings("pause_on_hover"), this.togglePauseOnHover("yes" === t)) : this.updateSwiperOption(e))
    }
    onEditSettingsChange(e) {
        "activeItemIndex" === e && void 0 !== this.swiper && this.swiper.slideToLoop(this.getEditSettings("activeItemIndex") - 1)
    }
    async onInit() {
        super.onInit(...arguments);
        var e = this.getElementSettings();
        if (this.elements.$swiperContainer.length && !(this.elements.$slides.length < 2)) {
            const t = elementorFrontend.utils.swiper;
            this.swiper = await new t(this.elements.$swiperContainer, this.getSwiperSettings()), this.elements.$swiperContainer.trigger("swiperInit"), this.elements.$swiperContainer.data("swiper", this.swiper), "yes" === e.pause_on_hover && this.togglePauseOnHover(!0)
        }
    }
    togglePauseOnHover(e) {
        e ? this.elements.$swiperContainer.on({
            mouseenter: () => {
                this.swiper.autoplay.stop()
            },
            mouseleave: () => {
                this.swiper.autoplay.start()
            }
        }) : this.elements.$swiperContainer.off("mouseenter mouseleave")
    }
}